<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/jessegoodier/kube-web-log-viewer/refs/heads/main/favicon.ico">
    <title>Kubernetes Log Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* dark:gray-700 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* dark:gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* dark:gray-500 */
        }
        .log-line mark { /* For search highlighting */
            background-color: #f6e05e; /* yellow-300 */
            color: #2d3748; /* gray-800 */
            padding: 0.1em;
            border-radius: 0.2em;
        }
        /* Basic transition for theme toggle */
        body, .bg-gray-100, .bg-gray-800, .text-gray-900, .text-gray-100 {
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans antialiased">

    <div class="container mx-auto px-4 py-4 min-h-screen flex flex-col">
        <header class="bg-white dark:bg-gray-800 shadow-md rounded-lg p-4 mb-4 sticky top-0 z-10">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-4 items-end">
                <div>
                    <label for="podSelector" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Pod <a href="#" id="refreshPods" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Refresh)</a></label>
                    <select id="podSelector" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all">All Pods</option>
                    </select>
                </div>

                <div>
                    <label for="sortOrder" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Sort Order</label>
                    <select id="sortOrder" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="asc">Newest First</option>
                        <option value="desc">Oldest First</option>
                    </select>
                </div>

                <div>
                    <label for="numLines" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Lines</label>
                    <select id="numLines" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="100">Last 100</option>
                        <option value="1000">Last 1000</option>
                        <option value="0">All</option>
                    </select>
                </div>

                <div>
                    <label for="timestampType" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Timestamp</label>
                    <select id="timestampType" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="since">Time Since</option>
                        <option value="utc">UTC</option>
                    </select>
                </div>

                <div class="lg:col-span-1 xl:col-span-1">
                    <label for="searchBox" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Search <a href="#" id="clearSearch" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Clear)</a></label>
                    <input type="text" id="searchBox" placeholder="Enter to search..." class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                </div>

                <div>
                    <label for="themeToggle" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Options</label>
                    <div class="flex gap-2">
                        <button id="themeToggle" class="flex-1 py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:bg-indigo-500 dark:hover:bg-indigo-600">
                            Toggle Light/Dark
                        </button>
                        <button id="followToggle" class="flex-1 py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gray-500 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                            Follow Off
                        </button>
                    </div>
                </div>
            </div>
            <div id="namespaceDisplay" class="mt-3 text-xs text-gray-500 dark:text-gray-400">Namespace: <span id="namespaceValue">Loading...</span></div>
            <div id="errorDisplay" class="mt-2 text-sm text-red-600 dark:text-red-400"></div>
            <div id="loadingIndicator" class="hidden mt-2">
                <div class="loader"></div>
                <p class="text-center text-sm text-gray-500 dark:text-gray-400">Loading logs...</p>
            </div>
        </header>

        <main class="flex-grow bg-white dark:bg-gray-800 shadow-md rounded-lg p-4 overflow-hidden">
            <pre id="logOutput" class="whitespace-pre-wrap break-all overflow-auto h-full text-sm leading-relaxed"></pre>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const podSelector = document.getElementById('podSelector');
            const sortOrder = document.getElementById('sortOrder');
            const numLines = document.getElementById('numLines');
            const timestampType = document.getElementById('timestampType');
            const searchBox = document.getElementById('searchBox');
            const themeToggle = document.getElementById('themeToggle');
            const logOutput = document.getElementById('logOutput');
            const namespaceValue = document.getElementById('namespaceValue');
            const errorDisplay = document.getElementById('errorDisplay');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const clearSearch = document.getElementById('clearSearch');
            const refreshPods = document.getElementById('refreshPods');
            const followToggle = document.getElementById('followToggle');

            let currentLogs = [];
            let eventSource = null;
            let isFollowing = false;

            // --- Theme Toggle ---
            const applyTheme = () => {
                if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            };

            themeToggle.addEventListener('click', () => {
                if (localStorage.theme === 'dark') {
                    localStorage.theme = 'light';
                    themeToggle.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                    themeToggle.classList.add('bg-gray-500', 'hover:bg-gray-600');
                } else {
                    localStorage.theme = 'dark';
                    themeToggle.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                    themeToggle.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                }
                applyTheme();
            });
            applyTheme();

            // --- API Calls ---
            async function fetchFromServer(endpoint, options = {}) {
                errorDisplay.textContent = '';
                try {
                    const absoluteUrl = new URL(endpoint, window.location.href).href;
                    const response = await fetch(absoluteUrl, options);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: `HTTP error! status: ${response.status} on ${absoluteUrl}` }));
                        throw new Error(errorData.message || `HTTP error! status: ${response.status} on ${absoluteUrl}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching ${endpoint} (resolved to ${new URL(endpoint, window.location.href).href}):`, error);
                    errorDisplay.textContent = `Error: ${error.message}`;
                    throw error;
                }
            }

            async function fetchPods() {
                try {
                    // Fetch live pods
                    const livePodsData = await fetchFromServer('/api/pods');
                    namespaceValue.textContent = livePodsData.namespace || 'N/A';

                    // Fetch archived pods
                    let archivedPodsData = { archived_pods: [] }; // Default empty
                    try {
                        // This endpoint might not be available or archival might be disabled
                        archivedPodsData = await fetchFromServer('/api/archived_pods');
                    } catch (error) {
                        console.warn("Could not fetch archived pods, possibly disabled:", error.message);
                        // Do not display error for this, as it might be an expected state
                    }

                    podSelector.innerHTML = '<option value="all">All Pods</option>';

                    const createOption = (value, text, isArchived = false) => {
                        const option = document.createElement('option');
                        option.value = isArchived ? `archived:${value}` : value;
                        option.textContent = text;
                        if (isArchived) {
                            option.dataset.isArchived = "true";
                        }
                        return option;
                    };

                    let hasLivePods = false;
                    if (livePodsData.pods && livePodsData.pods.length > 0) {
                        hasLivePods = true;
                        const liveGroup = document.createElement('optgroup');
                        liveGroup.label = "Live Pods";
                        livePodsData.pods.forEach(podName => {
                            liveGroup.appendChild(createOption(podName, podName));
                        });
                        podSelector.appendChild(liveGroup);
                    }

                    let hasArchivedPods = false;
                    if (archivedPodsData.archived_pods && archivedPodsData.archived_pods.length > 0) {
                        // Filter out archived pods that have matching live pods
                        const livePodNames = new Set(livePodsData.pods || []);
                        const filteredArchivedPods = archivedPodsData.archived_pods.filter(
                            podName => !livePodNames.has(podName)
                        );

                        if (filteredArchivedPods.length > 0) {
                            hasArchivedPods = true;
                            const archivedGroup = document.createElement('optgroup');
                            archivedGroup.label = "Archived Logs";
                            filteredArchivedPods.forEach(podName => {
                                archivedGroup.appendChild(createOption(podName, podName, true));
                            });
                            podSelector.appendChild(archivedGroup);
                        }
                    }

                    if (!hasLivePods && !hasArchivedPods) {
                        podSelector.innerHTML = '<option value="all">No pods or archived logs found</option>';
                    }

                    // Select "All Pods" by default
                    podSelector.value = "all";
                    fetchAndDisplayLogs();
                } catch (error) {
                    // This catch is mainly for errors from /api/pods now
                    namespaceValue.textContent = 'Error loading';
                    errorDisplay.textContent = `Error fetching pod list: ${error.message}`;
                    podSelector.innerHTML = '<option value="all">Error loading pods</option>';
                }
            }

            async function fetchAndDisplayLogs() {
                const selectedOption = podSelector.options[podSelector.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    logOutput.textContent = 'Please select a pod to view logs.';
                    currentLogs = [];
                    return;
                }

                const selectedValue = selectedOption.value;
                const isArchivedLog = selectedOption.dataset.isArchived === "true";
                const actualPodName = isArchivedLog ? selectedValue.substring("archived:".length) : selectedValue;

                // Close any existing event source
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
                // If switching to an archived log or from a live log, ensure follow is off.
                if (isArchivedLog && isFollowing) {
                    isFollowing = false;
                    followToggle.textContent = 'Follow Off';
                    followToggle.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
                    followToggle.classList.add('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-500');
                }
                followToggle.disabled = isArchivedLog; // Disable follow for archived logs
                if(isArchivedLog) {
                     followToggle.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    followToggle.classList.remove('opacity-50', 'cursor-not-allowed');
                }

                loadingIndicator.classList.remove('hidden');
                logOutput.textContent = '';

                const params = new URLSearchParams({
                    pod_name: actualPodName,
                    sort_order: isArchivedLog ? (sortOrder.value === 'asc' ? 'desc' : 'asc') : sortOrder.value,
                    tail_lines: numLines.value,
                    search_string: searchBox.value.trim(),
                });

                // Only add 'follow' for live logs and if isFollowing is true
                if (!isArchivedLog && isFollowing) {
                    params.append('follow', 'true');
                }

                const apiEndpoint = isArchivedLog ? '/api/archived_logs' : '/api/logs';

                try {
                    if (!isArchivedLog && isFollowing) {
                        // First, fetch initial logs without follow
                        const initialParams = new URLSearchParams(params);
                        initialParams.delete('follow');
                        const initialData = await fetchFromServer(`${apiEndpoint}?${initialParams.toString()}`);
                        currentLogs = initialData.logs || [];
                        renderLogs();

                        // Then set up SSE for following
                        eventSource = new EventSource(`${apiEndpoint}?${params.toString()}`);

                        eventSource.onmessage = (event) => {
                            try {
                                console.log('Received SSE message:', event.data);
                                const logEntry = JSON.parse(event.data);
                                if (logEntry.error) {
                                    console.error('Log entry contains error:', logEntry.error);
                                    errorDisplay.textContent = `Error: ${logEntry.error}`;
                                    eventSource.close();
                                    return;
                                }
                                console.log('Parsed log entry:', logEntry);
                                // For all pods view, append logs to maintain correct order
                                if (podSelector.value === 'all') {
                                    currentLogs.push(logEntry);
                                    console.log('Added log to currentLogs (all pods). Current length:', currentLogs.length);
                                } else {
                                    currentLogs.unshift(logEntry);
                                    console.log('Added log to currentLogs (single pod). Current length:', currentLogs.length);
                                }
                                if (currentLogs.length > 1000) { // Keep only last 1000 for performance
                                    currentLogs = currentLogs.slice(-1000);
                                    console.log('Trimmed logs to 1000 entries');
                                }
                                console.log('Calling renderLogs');
                                renderLogs();
                            } catch (error) {
                                console.error('Error in SSE message handler:', error);
                                errorDisplay.textContent = `Error processing log entry: ${error.message}`;
                            }
                        };

                        eventSource.onerror = (error) => {
                            console.error('EventSource error:', error);
                            errorDisplay.textContent = 'Error: Lost connection to log stream';
                            eventSource.close();
                            eventSource = null;
                            isFollowing = false; // Reset follow state
                            followToggle.textContent = 'Follow Off';
                            followToggle.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
                            followToggle.classList.add('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-500');
                        };

                        eventSource.onopen = () => {
                            console.log('SSE connection opened');
                        };
                    } else {
                        // Regular fetch for non-following mode (live or archived)
                        console.log('Fetching logs with params:', params.toString());
                        const data = await fetchFromServer(`${apiEndpoint}?${params.toString()}`);
                        console.log('Received log data:', data);
                        if (!data.logs) {
                            console.error('No logs array in response:', data);
                            throw new Error('Invalid response format: missing logs array');
                        }
                        currentLogs = data.logs;
                        console.log('Setting currentLogs, length:', currentLogs.length);
                        renderLogs();
                    }
                } catch (error) {
                    console.error('Error in fetchAndDisplayLogs:', error);
                    currentLogs = [];
                    errorDisplay.textContent = `Error loading logs: ${error.message}`;
                    logOutput.textContent = 'Error loading logs. Check console for details.';
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // --- Log Rendering ---
            function renderLogs() {
                console.log('Starting renderLogs, currentLogs length:', currentLogs.length);
                logOutput.innerHTML = '';

                if (!Array.isArray(currentLogs)) {
                    console.error('currentLogs is not an array:', currentLogs);
                    errorDisplay.textContent = 'Error: Invalid log data format';
                    return;
                }

                if (currentLogs.length === 0) {
                    logOutput.textContent = 'No logs to display for the current selection.';
                    if (searchBox.value.trim() && podSelector.value) {
                         logOutput.textContent += `\nOr no logs match your search term: "${searchBox.value.trim()}"`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                const searchTerm = searchBox.value.trim(); // For search highlighting

                // Define pod colors - using a mix of colors that work well in both light and dark modes
                const podColors = [
                    ['text-blue-600', 'dark:text-blue-400'],
                    ['text-purple-600', 'dark:text-purple-400'],
                    ['text-cyan-600', 'dark:text-cyan-400'],
                    ['text-emerald-600', 'dark:text-emerald-400'],
                    ['text-amber-600', 'dark:text-amber-400'],
                    ['text-rose-600', 'dark:text-rose-400'],
                    ['text-violet-600', 'dark:text-violet-400'],
                    ['text-teal-600', 'dark:text-teal-400'],
                    ['text-orange-600', 'dark:text-orange-400'],
                    ['text-pink-600', 'dark:text-pink-400']
                ];

                // Create a map to assign consistent colors to pods
                const podColorMap = new Map();
                let colorIndex = 0;

                const logColoringRules = {
                    error: {
                        terms: ['error', 'err', 'fatal', 'panic', 'exception', 'critical', 'failed', 'failure'],
                        classes: ['text-red-600', 'dark:text-red-400', 'font-semibold']
                    },
                    warning: {
                        terms: ['warning', 'warn', 'wrn'],
                        classes: ['text-orange-500', 'dark:text-orange-400']
                    },
                    info: {
                        terms: ['info', 'notice', 'inf'],
                        classes: ['text-green-600', 'dark:text-green-400']
                    }
                };

                currentLogs.forEach(logEntry => {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('log-line', 'py-0.5');

                    // Assign color to pod if viewing all pods
                    if (podSelector.value === 'all' && logEntry.pod_name) {
                        if (!podColorMap.has(logEntry.pod_name)) {
                            podColorMap.set(logEntry.pod_name, podColors[colorIndex % podColors.length]);
                            colorIndex++;
                        }
                        const podColor = podColorMap.get(logEntry.pod_name);

                        const podSpan = document.createElement('span');
                        podSpan.classList.add('mr-3', 'font-medium', ...podColor);
                        podSpan.textContent = `[${logEntry.pod_name}] `;
                        lineDiv.appendChild(podSpan);
                    }

                    const timestampSpan = document.createElement('span');
                    timestampSpan.classList.add('mr-3', 'text-gray-500', 'dark:text-gray-400', 'select-none');
                    timestampSpan.textContent = formatTimestamp(logEntry.timestamp) + ' ';

                    const messageSpan = document.createElement('span');
                    messageSpan.classList.add('log-message');

                    let messageContent = logEntry.message; // Original message content

                    // Apply keyword coloring first
                    let coloredMessageContent = messageContent;
                    const levelsInOrder = ['error', 'warning', 'info']; // Process in this order

                    for (const level of levelsInOrder) {
                        const rule = logColoringRules[level];
                        if (rule) {
                            for (const term of rule.terms) {
                                // Regex for whole word, case-insensitive
                                // \b ensures "word boundary"
                                const termRegex = new RegExp(`\\b(${escapeRegExp(term)})\\b`, 'gi');
                                coloredMessageContent = coloredMessageContent.replace(termRegex, (match) => {
                                    return `<span class="${rule.classes.join(' ')}">${match}</span>`;
                                });
                            }
                        }
                    }

                    // Apply search highlighting on the potentially colorized message
                    if (searchTerm) {
                        const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
                        coloredMessageContent = coloredMessageContent.replace(searchRegex, (match, p1) => {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = coloredMessageContent;
                            if (tempDiv.textContent.includes(match)) {
                                return `<mark>${p1}</mark>`;
                            }
                            return match;
                        });
                    }

                    messageSpan.innerHTML = coloredMessageContent;

                    lineDiv.appendChild(timestampSpan);
                    lineDiv.appendChild(messageSpan);
                    fragment.appendChild(lineDiv);
                });
                logOutput.appendChild(fragment);
            }

            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // --- Timestamp Formatting ---
            function formatTimestamp(utcTimestamp) {
                if (!utcTimestamp) return "[No Timestamp]";
                const date = new Date(utcTimestamp);
                if (isNaN(date)) return "[Invalid Date]";

                if (timestampType.value === 'utc') {
                    return date.toISOString();
                } else {
                    return timeSince(date);
                }
            }

            function timeSince(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + "y ago";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + "mo ago";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + "d ago";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + "h ago";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + "m ago";
                if (seconds < 0) return "just now";
                return Math.max(0, Math.floor(seconds)) + "s ago";
            }

            // --- Event Listeners ---
            podSelector.addEventListener('change', () => {
                logOutput.textContent = '';
                currentLogs = [];
                fetchAndDisplayLogs();
            });
            sortOrder.addEventListener('change', fetchAndDisplayLogs);
            numLines.addEventListener('change', fetchAndDisplayLogs);
            timestampType.addEventListener('change', renderLogs);

            followToggle.addEventListener('click', () => {
                isFollowing = !isFollowing;
                followToggle.textContent = isFollowing ? 'Follow On' : 'Follow Off';
                if (isFollowing) {
                    followToggle.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-500');
                    followToggle.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
                } else {
                    followToggle.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
                    followToggle.classList.add('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-500');
                }
                fetchAndDisplayLogs();
            });

            searchBox.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    fetchAndDisplayLogs();
                }
            });

            clearSearch.addEventListener('click', (event) => {
                event.preventDefault();
                searchBox.value = '';
                fetchAndDisplayLogs();
            });

            refreshPods.addEventListener('click', (event) => {
                event.preventDefault();
                loadingIndicator.classList.remove('hidden');
                fetchPods().finally(() => {
                    loadingIndicator.classList.add('hidden');
                });
            });

            // Initial data fetch
            fetchPods();
        });
    </script>
</body>
</html>